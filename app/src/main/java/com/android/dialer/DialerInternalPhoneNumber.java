// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packages/apps/Dialer/java/com/android/dialer/phonenumberproto/dialer_phone_number.proto

package com.android.dialer;

/**
 * <pre>
 * This is a copy of libphonenumber proto file for use in the dialer codebase.
 * We cannot depend on the real libphonenumber proto because it is not exposed
 * in any open source library. As such, this file could fall out of sync with
 * that proto over time.
 * The only difference between this proto and the libphonenumber proto (as of
 * when this file was created) is the package name and proto name.
 * If the libphonenumber proto becomes accessible some day, it may be possible
 * to remove this proto and use the real libphonenumber proto assuming this
 * proto is kept wire-compatible with it.
 * </pre>
 *
 * Protobuf type {@code com.android.dialer.DialerInternalPhoneNumber}
 */
public  final class DialerInternalPhoneNumber extends
    com.google.protobuf.GeneratedMessageLite<
        DialerInternalPhoneNumber, DialerInternalPhoneNumber.Builder> implements
    // @@protoc_insertion_point(message_implements:com.android.dialer.DialerInternalPhoneNumber)
    DialerInternalPhoneNumberOrBuilder {
  private DialerInternalPhoneNumber() {
    countryCode_ = 0;
    nationalNumber_ = 0L;
    extension_ = "";
    italianLeadingZero_ = false;
    numberOfLeadingZeros_ = 1;
    rawInput_ = "";
    countryCodeSource_ = 1;
    preferredDomesticCarrierCode_ = "";
  }
  /**
   * <pre>
   * The source from which the country_code is derived. This is not set in the
   * general parsing method, but in the method that parses and keeps raw_input.
   * New fields could be added upon request.
   * </pre>
   *
   * Protobuf enum {@code com.android.dialer.DialerInternalPhoneNumber.CountryCodeSource}
   */
  public enum CountryCodeSource
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * The country_code is derived based on a phone number with a leading "+",
     * e.g. the French number "+33 1 42 68 53 00".
     * </pre>
     *
     * <code>FROM_NUMBER_WITH_PLUS_SIGN = 1;</code>
     */
    FROM_NUMBER_WITH_PLUS_SIGN(1),
    /**
     * <pre>
     * The country_code is derived based on a phone number with a leading IDD,
     * e.g. the French number "011 33 1 42 68 53 00", as it is dialled from US.
     * </pre>
     *
     * <code>FROM_NUMBER_WITH_IDD = 5;</code>
     */
    FROM_NUMBER_WITH_IDD(5),
    /**
     * <pre>
     * The country_code is derived based on a phone number without a leading
     * "+", e.g. the French number "33 1 42 68 53 00" when defaultCountry is
     * supplied as France.
     * </pre>
     *
     * <code>FROM_NUMBER_WITHOUT_PLUS_SIGN = 10;</code>
     */
    FROM_NUMBER_WITHOUT_PLUS_SIGN(10),
    /**
     * <pre>
     * The country_code is derived NOT based on the phone number itself, but
     * from the defaultCountry parameter provided in the parsing function by the
     * clients. This happens mostly for numbers written in the national format
     * (without country code). For example, this would be set when parsing the
     * French number "01 42 68 53 00", when defaultCountry is supplied as
     * France.
     * </pre>
     *
     * <code>FROM_DEFAULT_COUNTRY = 20;</code>
     */
    FROM_DEFAULT_COUNTRY(20),
    ;

    /**
     * <pre>
     * The country_code is derived based on a phone number with a leading "+",
     * e.g. the French number "+33 1 42 68 53 00".
     * </pre>
     *
     * <code>FROM_NUMBER_WITH_PLUS_SIGN = 1;</code>
     */
    public static final int FROM_NUMBER_WITH_PLUS_SIGN_VALUE = 1;
    /**
     * <pre>
     * The country_code is derived based on a phone number with a leading IDD,
     * e.g. the French number "011 33 1 42 68 53 00", as it is dialled from US.
     * </pre>
     *
     * <code>FROM_NUMBER_WITH_IDD = 5;</code>
     */
    public static final int FROM_NUMBER_WITH_IDD_VALUE = 5;
    /**
     * <pre>
     * The country_code is derived based on a phone number without a leading
     * "+", e.g. the French number "33 1 42 68 53 00" when defaultCountry is
     * supplied as France.
     * </pre>
     *
     * <code>FROM_NUMBER_WITHOUT_PLUS_SIGN = 10;</code>
     */
    public static final int FROM_NUMBER_WITHOUT_PLUS_SIGN_VALUE = 10;
    /**
     * <pre>
     * The country_code is derived NOT based on the phone number itself, but
     * from the defaultCountry parameter provided in the parsing function by the
     * clients. This happens mostly for numbers written in the national format
     * (without country code). For example, this would be set when parsing the
     * French number "01 42 68 53 00", when defaultCountry is supplied as
     * France.
     * </pre>
     *
     * <code>FROM_DEFAULT_COUNTRY = 20;</code>
     */
    public static final int FROM_DEFAULT_COUNTRY_VALUE = 20;


    public final int getNumber() {
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static CountryCodeSource valueOf(int value) {
      return forNumber(value);
    }

    public static CountryCodeSource forNumber(int value) {
      switch (value) {
        case 1: return FROM_NUMBER_WITH_PLUS_SIGN;
        case 5: return FROM_NUMBER_WITH_IDD;
        case 10: return FROM_NUMBER_WITHOUT_PLUS_SIGN;
        case 20: return FROM_DEFAULT_COUNTRY;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CountryCodeSource>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        CountryCodeSource> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CountryCodeSource>() {
            public CountryCodeSource findValueByNumber(int number) {
              return CountryCodeSource.forNumber(number);
            }
          };

    private final int value;

    private CountryCodeSource(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.android.dialer.DialerInternalPhoneNumber.CountryCodeSource)
  }

  private int bitField0_;
  public static final int COUNTRY_CODE_FIELD_NUMBER = 1;
  private int countryCode_;
  /**
   * <pre>
   * The country calling code for this number, as defined by the International
   * Telecommunication Union (ITU). For example, this would be 1 for NANPA
   * countries, and 33 for France.
   * </pre>
   *
   * <code>required int32 country_code = 1;</code>
   */
  public boolean hasCountryCode() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
  }
  /**
   * <pre>
   * The country calling code for this number, as defined by the International
   * Telecommunication Union (ITU). For example, this would be 1 for NANPA
   * countries, and 33 for France.
   * </pre>
   *
   * <code>required int32 country_code = 1;</code>
   */
  public int getCountryCode() {
    return countryCode_;
  }
  /**
   * <pre>
   * The country calling code for this number, as defined by the International
   * Telecommunication Union (ITU). For example, this would be 1 for NANPA
   * countries, and 33 for France.
   * </pre>
   *
   * <code>required int32 country_code = 1;</code>
   */
  private void setCountryCode(int value) {
    bitField0_ |= 0x00000001;
    countryCode_ = value;
  }
  /**
   * <pre>
   * The country calling code for this number, as defined by the International
   * Telecommunication Union (ITU). For example, this would be 1 for NANPA
   * countries, and 33 for France.
   * </pre>
   *
   * <code>required int32 country_code = 1;</code>
   */
  private void clearCountryCode() {
    bitField0_ = (bitField0_ & ~0x00000001);
    countryCode_ = 0;
  }

  public static final int NATIONAL_NUMBER_FIELD_NUMBER = 2;
  private long nationalNumber_;
  /**
   * <pre>
   * The National (significant) Number, as defined in International
   * Telecommunication Union (ITU) Recommendation E.164, without any leading
   * zero. The leading-zero is stored separately if required, since this is an
   * uint64 and hence cannot store such information. Do not use this field
   * directly: if you want the national significant number, call the
   * getNationalSignificantNumber method of PhoneNumberUtil.
   * For countries which have the concept of an "area code" or "national
   * destination code", this is included in the National (significant) Number.
   * Although the ITU says the maximum length should be 15, we have found longer
   * numbers in some countries e.g. Germany.
   * Note that the National (significant) Number does not contain the National
   * (trunk) prefix. Obviously, as a uint64, it will never contain any
   * formatting (hyphens, spaces, parentheses), nor any alphanumeric spellings.
   * </pre>
   *
   * <code>required uint64 national_number = 2 [jstype = JS_NUMBER];</code>
   */
  public boolean hasNationalNumber() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
  }
  /**
   * <pre>
   * The National (significant) Number, as defined in International
   * Telecommunication Union (ITU) Recommendation E.164, without any leading
   * zero. The leading-zero is stored separately if required, since this is an
   * uint64 and hence cannot store such information. Do not use this field
   * directly: if you want the national significant number, call the
   * getNationalSignificantNumber method of PhoneNumberUtil.
   * For countries which have the concept of an "area code" or "national
   * destination code", this is included in the National (significant) Number.
   * Although the ITU says the maximum length should be 15, we have found longer
   * numbers in some countries e.g. Germany.
   * Note that the National (significant) Number does not contain the National
   * (trunk) prefix. Obviously, as a uint64, it will never contain any
   * formatting (hyphens, spaces, parentheses), nor any alphanumeric spellings.
   * </pre>
   *
   * <code>required uint64 national_number = 2 [jstype = JS_NUMBER];</code>
   */
  public long getNationalNumber() {
    return nationalNumber_;
  }
  /**
   * <pre>
   * The National (significant) Number, as defined in International
   * Telecommunication Union (ITU) Recommendation E.164, without any leading
   * zero. The leading-zero is stored separately if required, since this is an
   * uint64 and hence cannot store such information. Do not use this field
   * directly: if you want the national significant number, call the
   * getNationalSignificantNumber method of PhoneNumberUtil.
   * For countries which have the concept of an "area code" or "national
   * destination code", this is included in the National (significant) Number.
   * Although the ITU says the maximum length should be 15, we have found longer
   * numbers in some countries e.g. Germany.
   * Note that the National (significant) Number does not contain the National
   * (trunk) prefix. Obviously, as a uint64, it will never contain any
   * formatting (hyphens, spaces, parentheses), nor any alphanumeric spellings.
   * </pre>
   *
   * <code>required uint64 national_number = 2 [jstype = JS_NUMBER];</code>
   */
  private void setNationalNumber(long value) {
    bitField0_ |= 0x00000002;
    nationalNumber_ = value;
  }
  /**
   * <pre>
   * The National (significant) Number, as defined in International
   * Telecommunication Union (ITU) Recommendation E.164, without any leading
   * zero. The leading-zero is stored separately if required, since this is an
   * uint64 and hence cannot store such information. Do not use this field
   * directly: if you want the national significant number, call the
   * getNationalSignificantNumber method of PhoneNumberUtil.
   * For countries which have the concept of an "area code" or "national
   * destination code", this is included in the National (significant) Number.
   * Although the ITU says the maximum length should be 15, we have found longer
   * numbers in some countries e.g. Germany.
   * Note that the National (significant) Number does not contain the National
   * (trunk) prefix. Obviously, as a uint64, it will never contain any
   * formatting (hyphens, spaces, parentheses), nor any alphanumeric spellings.
   * </pre>
   *
   * <code>required uint64 national_number = 2 [jstype = JS_NUMBER];</code>
   */
  private void clearNationalNumber() {
    bitField0_ = (bitField0_ & ~0x00000002);
    nationalNumber_ = 0L;
  }

  public static final int EXTENSION_FIELD_NUMBER = 3;
  private String extension_;
  /**
   * <pre>
   * Extension is not standardized in ITU recommendations, except for being
   * defined as a series of numbers with a maximum length of 40 digits. It is
   * defined as a string here to accommodate for the possible use of a leading
   * zero in the extension (organizations have complete freedom to do so, as
   * there is no standard defined). Other than digits, some other dialling
   * characters such as "," (indicating a wait) may be stored here.
   * </pre>
   *
   * <code>optional string extension = 3;</code>
   */
  public boolean hasExtension() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
  }
  /**
   * <pre>
   * Extension is not standardized in ITU recommendations, except for being
   * defined as a series of numbers with a maximum length of 40 digits. It is
   * defined as a string here to accommodate for the possible use of a leading
   * zero in the extension (organizations have complete freedom to do so, as
   * there is no standard defined). Other than digits, some other dialling
   * characters such as "," (indicating a wait) may be stored here.
   * </pre>
   *
   * <code>optional string extension = 3;</code>
   */
  public String getExtension() {
    return extension_;
  }
  /**
   * <pre>
   * Extension is not standardized in ITU recommendations, except for being
   * defined as a series of numbers with a maximum length of 40 digits. It is
   * defined as a string here to accommodate for the possible use of a leading
   * zero in the extension (organizations have complete freedom to do so, as
   * there is no standard defined). Other than digits, some other dialling
   * characters such as "," (indicating a wait) may be stored here.
   * </pre>
   *
   * <code>optional string extension = 3;</code>
   */
  public com.google.protobuf.ByteString
      getExtensionBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(extension_);
  }
  /**
   * <pre>
   * Extension is not standardized in ITU recommendations, except for being
   * defined as a series of numbers with a maximum length of 40 digits. It is
   * defined as a string here to accommodate for the possible use of a leading
   * zero in the extension (organizations have complete freedom to do so, as
   * there is no standard defined). Other than digits, some other dialling
   * characters such as "," (indicating a wait) may be stored here.
   * </pre>
   *
   * <code>optional string extension = 3;</code>
   */
  private void setExtension(
      String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
    extension_ = value;
  }
  /**
   * <pre>
   * Extension is not standardized in ITU recommendations, except for being
   * defined as a series of numbers with a maximum length of 40 digits. It is
   * defined as a string here to accommodate for the possible use of a leading
   * zero in the extension (organizations have complete freedom to do so, as
   * there is no standard defined). Other than digits, some other dialling
   * characters such as "," (indicating a wait) may be stored here.
   * </pre>
   *
   * <code>optional string extension = 3;</code>
   */
  private void clearExtension() {
    bitField0_ = (bitField0_ & ~0x00000004);
    extension_ = getDefaultInstance().getExtension();
  }
  /**
   * <pre>
   * Extension is not standardized in ITU recommendations, except for being
   * defined as a series of numbers with a maximum length of 40 digits. It is
   * defined as a string here to accommodate for the possible use of a leading
   * zero in the extension (organizations have complete freedom to do so, as
   * there is no standard defined). Other than digits, some other dialling
   * characters such as "," (indicating a wait) may be stored here.
   * </pre>
   *
   * <code>optional string extension = 3;</code>
   */
  private void setExtensionBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
    extension_ = value.toStringUtf8();
  }

  public static final int ITALIAN_LEADING_ZERO_FIELD_NUMBER = 4;
  private boolean italianLeadingZero_;
  /**
   * <pre>
   * In some countries, the national (significant) number starts with one or
   * more "0"s without this being a national prefix or trunk code of some kind.
   * For example, the leading zero in the national (significant) number of an
   * Italian phone number indicates the number is a fixed-line number.  There
   * have been plans to migrate fixed-line numbers to start with the digit two
   * since December 2000, but it has not happened yet. See
   * http://en.wikipedia.org/wiki/%2B39 for more details.
   * These fields can be safely ignored (there is no need to set them) for most
   * countries. Some limited number of countries behave like Italy - for these
   * cases, if the leading zero(s) of a number would be retained even when
   * dialling internationally, set this flag to true, and also set the number of
   * leading zeros.
   * Clients who use the parsing or conversion functionality of the i18n phone
   * number libraries (go/phonenumbers) will have these fields set if necessary
   * automatically.
   * </pre>
   *
   * <code>optional bool italian_leading_zero = 4;</code>
   */
  public boolean hasItalianLeadingZero() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
  }
  /**
   * <pre>
   * In some countries, the national (significant) number starts with one or
   * more "0"s without this being a national prefix or trunk code of some kind.
   * For example, the leading zero in the national (significant) number of an
   * Italian phone number indicates the number is a fixed-line number.  There
   * have been plans to migrate fixed-line numbers to start with the digit two
   * since December 2000, but it has not happened yet. See
   * http://en.wikipedia.org/wiki/%2B39 for more details.
   * These fields can be safely ignored (there is no need to set them) for most
   * countries. Some limited number of countries behave like Italy - for these
   * cases, if the leading zero(s) of a number would be retained even when
   * dialling internationally, set this flag to true, and also set the number of
   * leading zeros.
   * Clients who use the parsing or conversion functionality of the i18n phone
   * number libraries (go/phonenumbers) will have these fields set if necessary
   * automatically.
   * </pre>
   *
   * <code>optional bool italian_leading_zero = 4;</code>
   */
  public boolean getItalianLeadingZero() {
    return italianLeadingZero_;
  }
  /**
   * <pre>
   * In some countries, the national (significant) number starts with one or
   * more "0"s without this being a national prefix or trunk code of some kind.
   * For example, the leading zero in the national (significant) number of an
   * Italian phone number indicates the number is a fixed-line number.  There
   * have been plans to migrate fixed-line numbers to start with the digit two
   * since December 2000, but it has not happened yet. See
   * http://en.wikipedia.org/wiki/%2B39 for more details.
   * These fields can be safely ignored (there is no need to set them) for most
   * countries. Some limited number of countries behave like Italy - for these
   * cases, if the leading zero(s) of a number would be retained even when
   * dialling internationally, set this flag to true, and also set the number of
   * leading zeros.
   * Clients who use the parsing or conversion functionality of the i18n phone
   * number libraries (go/phonenumbers) will have these fields set if necessary
   * automatically.
   * </pre>
   *
   * <code>optional bool italian_leading_zero = 4;</code>
   */
  private void setItalianLeadingZero(boolean value) {
    bitField0_ |= 0x00000008;
    italianLeadingZero_ = value;
  }
  /**
   * <pre>
   * In some countries, the national (significant) number starts with one or
   * more "0"s without this being a national prefix or trunk code of some kind.
   * For example, the leading zero in the national (significant) number of an
   * Italian phone number indicates the number is a fixed-line number.  There
   * have been plans to migrate fixed-line numbers to start with the digit two
   * since December 2000, but it has not happened yet. See
   * http://en.wikipedia.org/wiki/%2B39 for more details.
   * These fields can be safely ignored (there is no need to set them) for most
   * countries. Some limited number of countries behave like Italy - for these
   * cases, if the leading zero(s) of a number would be retained even when
   * dialling internationally, set this flag to true, and also set the number of
   * leading zeros.
   * Clients who use the parsing or conversion functionality of the i18n phone
   * number libraries (go/phonenumbers) will have these fields set if necessary
   * automatically.
   * </pre>
   *
   * <code>optional bool italian_leading_zero = 4;</code>
   */
  private void clearItalianLeadingZero() {
    bitField0_ = (bitField0_ & ~0x00000008);
    italianLeadingZero_ = false;
  }

  public static final int NUMBER_OF_LEADING_ZEROS_FIELD_NUMBER = 8;
  private int numberOfLeadingZeros_;
  /**
   * <code>optional int32 number_of_leading_zeros = 8 [default = 1];</code>
   */
  public boolean hasNumberOfLeadingZeros() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
  }
  /**
   * <code>optional int32 number_of_leading_zeros = 8 [default = 1];</code>
   */
  public int getNumberOfLeadingZeros() {
    return numberOfLeadingZeros_;
  }
  /**
   * <code>optional int32 number_of_leading_zeros = 8 [default = 1];</code>
   */
  private void setNumberOfLeadingZeros(int value) {
    bitField0_ |= 0x00000010;
    numberOfLeadingZeros_ = value;
  }
  /**
   * <code>optional int32 number_of_leading_zeros = 8 [default = 1];</code>
   */
  private void clearNumberOfLeadingZeros() {
    bitField0_ = (bitField0_ & ~0x00000010);
    numberOfLeadingZeros_ = 1;
  }

  public static final int RAW_INPUT_FIELD_NUMBER = 5;
  private String rawInput_;
  /**
   * <pre>
   * This field is used to store the raw input string containing phone numbers
   * before it was canonicalized by the library. For example, it could be used
   * to store alphanumerical numbers such as "1-800-GOOG-411".
   * </pre>
   *
   * <code>optional string raw_input = 5;</code>
   */
  public boolean hasRawInput() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
  }
  /**
   * <pre>
   * This field is used to store the raw input string containing phone numbers
   * before it was canonicalized by the library. For example, it could be used
   * to store alphanumerical numbers such as "1-800-GOOG-411".
   * </pre>
   *
   * <code>optional string raw_input = 5;</code>
   */
  public String getRawInput() {
    return rawInput_;
  }
  /**
   * <pre>
   * This field is used to store the raw input string containing phone numbers
   * before it was canonicalized by the library. For example, it could be used
   * to store alphanumerical numbers such as "1-800-GOOG-411".
   * </pre>
   *
   * <code>optional string raw_input = 5;</code>
   */
  public com.google.protobuf.ByteString
      getRawInputBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(rawInput_);
  }
  /**
   * <pre>
   * This field is used to store the raw input string containing phone numbers
   * before it was canonicalized by the library. For example, it could be used
   * to store alphanumerical numbers such as "1-800-GOOG-411".
   * </pre>
   *
   * <code>optional string raw_input = 5;</code>
   */
  private void setRawInput(
      String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
    rawInput_ = value;
  }
  /**
   * <pre>
   * This field is used to store the raw input string containing phone numbers
   * before it was canonicalized by the library. For example, it could be used
   * to store alphanumerical numbers such as "1-800-GOOG-411".
   * </pre>
   *
   * <code>optional string raw_input = 5;</code>
   */
  private void clearRawInput() {
    bitField0_ = (bitField0_ & ~0x00000020);
    rawInput_ = getDefaultInstance().getRawInput();
  }
  /**
   * <pre>
   * This field is used to store the raw input string containing phone numbers
   * before it was canonicalized by the library. For example, it could be used
   * to store alphanumerical numbers such as "1-800-GOOG-411".
   * </pre>
   *
   * <code>optional string raw_input = 5;</code>
   */
  private void setRawInputBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
    rawInput_ = value.toStringUtf8();
  }

  public static final int COUNTRY_CODE_SOURCE_FIELD_NUMBER = 6;
  private int countryCodeSource_;
  /**
   * <pre>
   * The source from which the country_code is derived.
   * </pre>
   *
   * <code>optional .com.android.dialer.DialerInternalPhoneNumber.CountryCodeSource country_code_source = 6;</code>
   */
  public boolean hasCountryCodeSource() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
  }
  /**
   * <pre>
   * The source from which the country_code is derived.
   * </pre>
   *
   * <code>optional .com.android.dialer.DialerInternalPhoneNumber.CountryCodeSource country_code_source = 6;</code>
   */
  public CountryCodeSource getCountryCodeSource() {
    CountryCodeSource result = CountryCodeSource.forNumber(countryCodeSource_);
    return result == null ? CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN : result;
  }
  /**
   * <pre>
   * The source from which the country_code is derived.
   * </pre>
   *
   * <code>optional .com.android.dialer.DialerInternalPhoneNumber.CountryCodeSource country_code_source = 6;</code>
   */
  private void setCountryCodeSource(CountryCodeSource value) {
    if (value == null) {
      throw new NullPointerException();
    }
    bitField0_ |= 0x00000040;
    countryCodeSource_ = value.getNumber();
  }
  /**
   * <pre>
   * The source from which the country_code is derived.
   * </pre>
   *
   * <code>optional .com.android.dialer.DialerInternalPhoneNumber.CountryCodeSource country_code_source = 6;</code>
   */
  private void clearCountryCodeSource() {
    bitField0_ = (bitField0_ & ~0x00000040);
    countryCodeSource_ = 1;
  }

  public static final int PREFERRED_DOMESTIC_CARRIER_CODE_FIELD_NUMBER = 7;
  private String preferredDomesticCarrierCode_;
  /**
   * <pre>
   * The carrier selection code that is preferred when calling this phone number
   * domestically. This also includes codes that need to be dialed in some
   * countries when calling from landlines to mobiles or vice versa. For
   * example, in Columbia, a "3" needs to be dialed before the phone number
   * itself when calling from a mobile phone to a domestic landline phone and
   * vice versa.
   * Note this is the "preferred" code, which means other codes may work as
   * well.
   * </pre>
   *
   * <code>optional string preferred_domestic_carrier_code = 7;</code>
   */
  public boolean hasPreferredDomesticCarrierCode() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
  }
  /**
   * <pre>
   * The carrier selection code that is preferred when calling this phone number
   * domestically. This also includes codes that need to be dialed in some
   * countries when calling from landlines to mobiles or vice versa. For
   * example, in Columbia, a "3" needs to be dialed before the phone number
   * itself when calling from a mobile phone to a domestic landline phone and
   * vice versa.
   * Note this is the "preferred" code, which means other codes may work as
   * well.
   * </pre>
   *
   * <code>optional string preferred_domestic_carrier_code = 7;</code>
   */
  public String getPreferredDomesticCarrierCode() {
    return preferredDomesticCarrierCode_;
  }
  /**
   * <pre>
   * The carrier selection code that is preferred when calling this phone number
   * domestically. This also includes codes that need to be dialed in some
   * countries when calling from landlines to mobiles or vice versa. For
   * example, in Columbia, a "3" needs to be dialed before the phone number
   * itself when calling from a mobile phone to a domestic landline phone and
   * vice versa.
   * Note this is the "preferred" code, which means other codes may work as
   * well.
   * </pre>
   *
   * <code>optional string preferred_domestic_carrier_code = 7;</code>
   */
  public com.google.protobuf.ByteString
      getPreferredDomesticCarrierCodeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(preferredDomesticCarrierCode_);
  }
  /**
   * <pre>
   * The carrier selection code that is preferred when calling this phone number
   * domestically. This also includes codes that need to be dialed in some
   * countries when calling from landlines to mobiles or vice versa. For
   * example, in Columbia, a "3" needs to be dialed before the phone number
   * itself when calling from a mobile phone to a domestic landline phone and
   * vice versa.
   * Note this is the "preferred" code, which means other codes may work as
   * well.
   * </pre>
   *
   * <code>optional string preferred_domestic_carrier_code = 7;</code>
   */
  private void setPreferredDomesticCarrierCode(
      String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
    preferredDomesticCarrierCode_ = value;
  }
  /**
   * <pre>
   * The carrier selection code that is preferred when calling this phone number
   * domestically. This also includes codes that need to be dialed in some
   * countries when calling from landlines to mobiles or vice versa. For
   * example, in Columbia, a "3" needs to be dialed before the phone number
   * itself when calling from a mobile phone to a domestic landline phone and
   * vice versa.
   * Note this is the "preferred" code, which means other codes may work as
   * well.
   * </pre>
   *
   * <code>optional string preferred_domestic_carrier_code = 7;</code>
   */
  private void clearPreferredDomesticCarrierCode() {
    bitField0_ = (bitField0_ & ~0x00000080);
    preferredDomesticCarrierCode_ = getDefaultInstance().getPreferredDomesticCarrierCode();
  }
  /**
   * <pre>
   * The carrier selection code that is preferred when calling this phone number
   * domestically. This also includes codes that need to be dialed in some
   * countries when calling from landlines to mobiles or vice versa. For
   * example, in Columbia, a "3" needs to be dialed before the phone number
   * itself when calling from a mobile phone to a domestic landline phone and
   * vice versa.
   * Note this is the "preferred" code, which means other codes may work as
   * well.
   * </pre>
   *
   * <code>optional string preferred_domestic_carrier_code = 7;</code>
   */
  private void setPreferredDomesticCarrierCodeBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
    preferredDomesticCarrierCode_ = value.toStringUtf8();
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      output.writeInt32(1, countryCode_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      output.writeUInt64(2, nationalNumber_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      output.writeString(3, getExtension());
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      output.writeBool(4, italianLeadingZero_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      output.writeString(5, getRawInput());
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      output.writeEnum(6, countryCodeSource_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      output.writeString(7, getPreferredDomesticCarrierCode());
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      output.writeInt32(8, numberOfLeadingZeros_);
    }
    unknownFields.writeTo(output);
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(1, countryCode_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt64Size(2, nationalNumber_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(3, getExtension());
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(4, italianLeadingZero_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(5, getRawInput());
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(6, countryCodeSource_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(7, getPreferredDomesticCarrierCode());
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(8, numberOfLeadingZeros_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSerializedSize = size;
    return size;
  }

  public static DialerInternalPhoneNumber parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static DialerInternalPhoneNumber parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static DialerInternalPhoneNumber parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static DialerInternalPhoneNumber parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static DialerInternalPhoneNumber parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static DialerInternalPhoneNumber parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static DialerInternalPhoneNumber parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static DialerInternalPhoneNumber parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static DialerInternalPhoneNumber parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static DialerInternalPhoneNumber parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(DialerInternalPhoneNumber prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * <pre>
   * This is a copy of libphonenumber proto file for use in the dialer codebase.
   * We cannot depend on the real libphonenumber proto because it is not exposed
   * in any open source library. As such, this file could fall out of sync with
   * that proto over time.
   * The only difference between this proto and the libphonenumber proto (as of
   * when this file was created) is the package name and proto name.
   * If the libphonenumber proto becomes accessible some day, it may be possible
   * to remove this proto and use the real libphonenumber proto assuming this
   * proto is kept wire-compatible with it.
   * </pre>
   *
   * Protobuf type {@code com.android.dialer.DialerInternalPhoneNumber}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        DialerInternalPhoneNumber, Builder> implements
      // @@protoc_insertion_point(builder_implements:com.android.dialer.DialerInternalPhoneNumber)
      com.android.dialer.DialerInternalPhoneNumberOrBuilder {
    // Construct using com.android.dialer.DialerInternalPhoneNumber.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The country calling code for this number, as defined by the International
     * Telecommunication Union (ITU). For example, this would be 1 for NANPA
     * countries, and 33 for France.
     * </pre>
     *
     * <code>required int32 country_code = 1;</code>
     */
    public boolean hasCountryCode() {
      return instance.hasCountryCode();
    }
    /**
     * <pre>
     * The country calling code for this number, as defined by the International
     * Telecommunication Union (ITU). For example, this would be 1 for NANPA
     * countries, and 33 for France.
     * </pre>
     *
     * <code>required int32 country_code = 1;</code>
     */
    public int getCountryCode() {
      return instance.getCountryCode();
    }
    /**
     * <pre>
     * The country calling code for this number, as defined by the International
     * Telecommunication Union (ITU). For example, this would be 1 for NANPA
     * countries, and 33 for France.
     * </pre>
     *
     * <code>required int32 country_code = 1;</code>
     */
    public Builder setCountryCode(int value) {
      copyOnWrite();
      instance.setCountryCode(value);
      return this;
    }
    /**
     * <pre>
     * The country calling code for this number, as defined by the International
     * Telecommunication Union (ITU). For example, this would be 1 for NANPA
     * countries, and 33 for France.
     * </pre>
     *
     * <code>required int32 country_code = 1;</code>
     */
    public Builder clearCountryCode() {
      copyOnWrite();
      instance.clearCountryCode();
      return this;
    }

    /**
     * <pre>
     * The National (significant) Number, as defined in International
     * Telecommunication Union (ITU) Recommendation E.164, without any leading
     * zero. The leading-zero is stored separately if required, since this is an
     * uint64 and hence cannot store such information. Do not use this field
     * directly: if you want the national significant number, call the
     * getNationalSignificantNumber method of PhoneNumberUtil.
     * For countries which have the concept of an "area code" or "national
     * destination code", this is included in the National (significant) Number.
     * Although the ITU says the maximum length should be 15, we have found longer
     * numbers in some countries e.g. Germany.
     * Note that the National (significant) Number does not contain the National
     * (trunk) prefix. Obviously, as a uint64, it will never contain any
     * formatting (hyphens, spaces, parentheses), nor any alphanumeric spellings.
     * </pre>
     *
     * <code>required uint64 national_number = 2 [jstype = JS_NUMBER];</code>
     */
    public boolean hasNationalNumber() {
      return instance.hasNationalNumber();
    }
    /**
     * <pre>
     * The National (significant) Number, as defined in International
     * Telecommunication Union (ITU) Recommendation E.164, without any leading
     * zero. The leading-zero is stored separately if required, since this is an
     * uint64 and hence cannot store such information. Do not use this field
     * directly: if you want the national significant number, call the
     * getNationalSignificantNumber method of PhoneNumberUtil.
     * For countries which have the concept of an "area code" or "national
     * destination code", this is included in the National (significant) Number.
     * Although the ITU says the maximum length should be 15, we have found longer
     * numbers in some countries e.g. Germany.
     * Note that the National (significant) Number does not contain the National
     * (trunk) prefix. Obviously, as a uint64, it will never contain any
     * formatting (hyphens, spaces, parentheses), nor any alphanumeric spellings.
     * </pre>
     *
     * <code>required uint64 national_number = 2 [jstype = JS_NUMBER];</code>
     */
    public long getNationalNumber() {
      return instance.getNationalNumber();
    }
    /**
     * <pre>
     * The National (significant) Number, as defined in International
     * Telecommunication Union (ITU) Recommendation E.164, without any leading
     * zero. The leading-zero is stored separately if required, since this is an
     * uint64 and hence cannot store such information. Do not use this field
     * directly: if you want the national significant number, call the
     * getNationalSignificantNumber method of PhoneNumberUtil.
     * For countries which have the concept of an "area code" or "national
     * destination code", this is included in the National (significant) Number.
     * Although the ITU says the maximum length should be 15, we have found longer
     * numbers in some countries e.g. Germany.
     * Note that the National (significant) Number does not contain the National
     * (trunk) prefix. Obviously, as a uint64, it will never contain any
     * formatting (hyphens, spaces, parentheses), nor any alphanumeric spellings.
     * </pre>
     *
     * <code>required uint64 national_number = 2 [jstype = JS_NUMBER];</code>
     */
    public Builder setNationalNumber(long value) {
      copyOnWrite();
      instance.setNationalNumber(value);
      return this;
    }
    /**
     * <pre>
     * The National (significant) Number, as defined in International
     * Telecommunication Union (ITU) Recommendation E.164, without any leading
     * zero. The leading-zero is stored separately if required, since this is an
     * uint64 and hence cannot store such information. Do not use this field
     * directly: if you want the national significant number, call the
     * getNationalSignificantNumber method of PhoneNumberUtil.
     * For countries which have the concept of an "area code" or "national
     * destination code", this is included in the National (significant) Number.
     * Although the ITU says the maximum length should be 15, we have found longer
     * numbers in some countries e.g. Germany.
     * Note that the National (significant) Number does not contain the National
     * (trunk) prefix. Obviously, as a uint64, it will never contain any
     * formatting (hyphens, spaces, parentheses), nor any alphanumeric spellings.
     * </pre>
     *
     * <code>required uint64 national_number = 2 [jstype = JS_NUMBER];</code>
     */
    public Builder clearNationalNumber() {
      copyOnWrite();
      instance.clearNationalNumber();
      return this;
    }

    /**
     * <pre>
     * Extension is not standardized in ITU recommendations, except for being
     * defined as a series of numbers with a maximum length of 40 digits. It is
     * defined as a string here to accommodate for the possible use of a leading
     * zero in the extension (organizations have complete freedom to do so, as
     * there is no standard defined). Other than digits, some other dialling
     * characters such as "," (indicating a wait) may be stored here.
     * </pre>
     *
     * <code>optional string extension = 3;</code>
     */
    public boolean hasExtension() {
      return instance.hasExtension();
    }
    /**
     * <pre>
     * Extension is not standardized in ITU recommendations, except for being
     * defined as a series of numbers with a maximum length of 40 digits. It is
     * defined as a string here to accommodate for the possible use of a leading
     * zero in the extension (organizations have complete freedom to do so, as
     * there is no standard defined). Other than digits, some other dialling
     * characters such as "," (indicating a wait) may be stored here.
     * </pre>
     *
     * <code>optional string extension = 3;</code>
     */
    public String getExtension() {
      return instance.getExtension();
    }
    /**
     * <pre>
     * Extension is not standardized in ITU recommendations, except for being
     * defined as a series of numbers with a maximum length of 40 digits. It is
     * defined as a string here to accommodate for the possible use of a leading
     * zero in the extension (organizations have complete freedom to do so, as
     * there is no standard defined). Other than digits, some other dialling
     * characters such as "," (indicating a wait) may be stored here.
     * </pre>
     *
     * <code>optional string extension = 3;</code>
     */
    public com.google.protobuf.ByteString
        getExtensionBytes() {
      return instance.getExtensionBytes();
    }
    /**
     * <pre>
     * Extension is not standardized in ITU recommendations, except for being
     * defined as a series of numbers with a maximum length of 40 digits. It is
     * defined as a string here to accommodate for the possible use of a leading
     * zero in the extension (organizations have complete freedom to do so, as
     * there is no standard defined). Other than digits, some other dialling
     * characters such as "," (indicating a wait) may be stored here.
     * </pre>
     *
     * <code>optional string extension = 3;</code>
     */
    public Builder setExtension(
        String value) {
      copyOnWrite();
      instance.setExtension(value);
      return this;
    }
    /**
     * <pre>
     * Extension is not standardized in ITU recommendations, except for being
     * defined as a series of numbers with a maximum length of 40 digits. It is
     * defined as a string here to accommodate for the possible use of a leading
     * zero in the extension (organizations have complete freedom to do so, as
     * there is no standard defined). Other than digits, some other dialling
     * characters such as "," (indicating a wait) may be stored here.
     * </pre>
     *
     * <code>optional string extension = 3;</code>
     */
    public Builder clearExtension() {
      copyOnWrite();
      instance.clearExtension();
      return this;
    }
    /**
     * <pre>
     * Extension is not standardized in ITU recommendations, except for being
     * defined as a series of numbers with a maximum length of 40 digits. It is
     * defined as a string here to accommodate for the possible use of a leading
     * zero in the extension (organizations have complete freedom to do so, as
     * there is no standard defined). Other than digits, some other dialling
     * characters such as "," (indicating a wait) may be stored here.
     * </pre>
     *
     * <code>optional string extension = 3;</code>
     */
    public Builder setExtensionBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setExtensionBytes(value);
      return this;
    }

    /**
     * <pre>
     * In some countries, the national (significant) number starts with one or
     * more "0"s without this being a national prefix or trunk code of some kind.
     * For example, the leading zero in the national (significant) number of an
     * Italian phone number indicates the number is a fixed-line number.  There
     * have been plans to migrate fixed-line numbers to start with the digit two
     * since December 2000, but it has not happened yet. See
     * http://en.wikipedia.org/wiki/%2B39 for more details.
     * These fields can be safely ignored (there is no need to set them) for most
     * countries. Some limited number of countries behave like Italy - for these
     * cases, if the leading zero(s) of a number would be retained even when
     * dialling internationally, set this flag to true, and also set the number of
     * leading zeros.
     * Clients who use the parsing or conversion functionality of the i18n phone
     * number libraries (go/phonenumbers) will have these fields set if necessary
     * automatically.
     * </pre>
     *
     * <code>optional bool italian_leading_zero = 4;</code>
     */
    public boolean hasItalianLeadingZero() {
      return instance.hasItalianLeadingZero();
    }
    /**
     * <pre>
     * In some countries, the national (significant) number starts with one or
     * more "0"s without this being a national prefix or trunk code of some kind.
     * For example, the leading zero in the national (significant) number of an
     * Italian phone number indicates the number is a fixed-line number.  There
     * have been plans to migrate fixed-line numbers to start with the digit two
     * since December 2000, but it has not happened yet. See
     * http://en.wikipedia.org/wiki/%2B39 for more details.
     * These fields can be safely ignored (there is no need to set them) for most
     * countries. Some limited number of countries behave like Italy - for these
     * cases, if the leading zero(s) of a number would be retained even when
     * dialling internationally, set this flag to true, and also set the number of
     * leading zeros.
     * Clients who use the parsing or conversion functionality of the i18n phone
     * number libraries (go/phonenumbers) will have these fields set if necessary
     * automatically.
     * </pre>
     *
     * <code>optional bool italian_leading_zero = 4;</code>
     */
    public boolean getItalianLeadingZero() {
      return instance.getItalianLeadingZero();
    }
    /**
     * <pre>
     * In some countries, the national (significant) number starts with one or
     * more "0"s without this being a national prefix or trunk code of some kind.
     * For example, the leading zero in the national (significant) number of an
     * Italian phone number indicates the number is a fixed-line number.  There
     * have been plans to migrate fixed-line numbers to start with the digit two
     * since December 2000, but it has not happened yet. See
     * http://en.wikipedia.org/wiki/%2B39 for more details.
     * These fields can be safely ignored (there is no need to set them) for most
     * countries. Some limited number of countries behave like Italy - for these
     * cases, if the leading zero(s) of a number would be retained even when
     * dialling internationally, set this flag to true, and also set the number of
     * leading zeros.
     * Clients who use the parsing or conversion functionality of the i18n phone
     * number libraries (go/phonenumbers) will have these fields set if necessary
     * automatically.
     * </pre>
     *
     * <code>optional bool italian_leading_zero = 4;</code>
     */
    public Builder setItalianLeadingZero(boolean value) {
      copyOnWrite();
      instance.setItalianLeadingZero(value);
      return this;
    }
    /**
     * <pre>
     * In some countries, the national (significant) number starts with one or
     * more "0"s without this being a national prefix or trunk code of some kind.
     * For example, the leading zero in the national (significant) number of an
     * Italian phone number indicates the number is a fixed-line number.  There
     * have been plans to migrate fixed-line numbers to start with the digit two
     * since December 2000, but it has not happened yet. See
     * http://en.wikipedia.org/wiki/%2B39 for more details.
     * These fields can be safely ignored (there is no need to set them) for most
     * countries. Some limited number of countries behave like Italy - for these
     * cases, if the leading zero(s) of a number would be retained even when
     * dialling internationally, set this flag to true, and also set the number of
     * leading zeros.
     * Clients who use the parsing or conversion functionality of the i18n phone
     * number libraries (go/phonenumbers) will have these fields set if necessary
     * automatically.
     * </pre>
     *
     * <code>optional bool italian_leading_zero = 4;</code>
     */
    public Builder clearItalianLeadingZero() {
      copyOnWrite();
      instance.clearItalianLeadingZero();
      return this;
    }

    /**
     * <code>optional int32 number_of_leading_zeros = 8 [default = 1];</code>
     */
    public boolean hasNumberOfLeadingZeros() {
      return instance.hasNumberOfLeadingZeros();
    }
    /**
     * <code>optional int32 number_of_leading_zeros = 8 [default = 1];</code>
     */
    public int getNumberOfLeadingZeros() {
      return instance.getNumberOfLeadingZeros();
    }
    /**
     * <code>optional int32 number_of_leading_zeros = 8 [default = 1];</code>
     */
    public Builder setNumberOfLeadingZeros(int value) {
      copyOnWrite();
      instance.setNumberOfLeadingZeros(value);
      return this;
    }
    /**
     * <code>optional int32 number_of_leading_zeros = 8 [default = 1];</code>
     */
    public Builder clearNumberOfLeadingZeros() {
      copyOnWrite();
      instance.clearNumberOfLeadingZeros();
      return this;
    }

    /**
     * <pre>
     * This field is used to store the raw input string containing phone numbers
     * before it was canonicalized by the library. For example, it could be used
     * to store alphanumerical numbers such as "1-800-GOOG-411".
     * </pre>
     *
     * <code>optional string raw_input = 5;</code>
     */
    public boolean hasRawInput() {
      return instance.hasRawInput();
    }
    /**
     * <pre>
     * This field is used to store the raw input string containing phone numbers
     * before it was canonicalized by the library. For example, it could be used
     * to store alphanumerical numbers such as "1-800-GOOG-411".
     * </pre>
     *
     * <code>optional string raw_input = 5;</code>
     */
    public String getRawInput() {
      return instance.getRawInput();
    }
    /**
     * <pre>
     * This field is used to store the raw input string containing phone numbers
     * before it was canonicalized by the library. For example, it could be used
     * to store alphanumerical numbers such as "1-800-GOOG-411".
     * </pre>
     *
     * <code>optional string raw_input = 5;</code>
     */
    public com.google.protobuf.ByteString
        getRawInputBytes() {
      return instance.getRawInputBytes();
    }
    /**
     * <pre>
     * This field is used to store the raw input string containing phone numbers
     * before it was canonicalized by the library. For example, it could be used
     * to store alphanumerical numbers such as "1-800-GOOG-411".
     * </pre>
     *
     * <code>optional string raw_input = 5;</code>
     */
    public Builder setRawInput(
        String value) {
      copyOnWrite();
      instance.setRawInput(value);
      return this;
    }
    /**
     * <pre>
     * This field is used to store the raw input string containing phone numbers
     * before it was canonicalized by the library. For example, it could be used
     * to store alphanumerical numbers such as "1-800-GOOG-411".
     * </pre>
     *
     * <code>optional string raw_input = 5;</code>
     */
    public Builder clearRawInput() {
      copyOnWrite();
      instance.clearRawInput();
      return this;
    }
    /**
     * <pre>
     * This field is used to store the raw input string containing phone numbers
     * before it was canonicalized by the library. For example, it could be used
     * to store alphanumerical numbers such as "1-800-GOOG-411".
     * </pre>
     *
     * <code>optional string raw_input = 5;</code>
     */
    public Builder setRawInputBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setRawInputBytes(value);
      return this;
    }

    /**
     * <pre>
     * The source from which the country_code is derived.
     * </pre>
     *
     * <code>optional .com.android.dialer.DialerInternalPhoneNumber.CountryCodeSource country_code_source = 6;</code>
     */
    public boolean hasCountryCodeSource() {
      return instance.hasCountryCodeSource();
    }
    /**
     * <pre>
     * The source from which the country_code is derived.
     * </pre>
     *
     * <code>optional .com.android.dialer.DialerInternalPhoneNumber.CountryCodeSource country_code_source = 6;</code>
     */
    public CountryCodeSource getCountryCodeSource() {
      return instance.getCountryCodeSource();
    }
    /**
     * <pre>
     * The source from which the country_code is derived.
     * </pre>
     *
     * <code>optional .com.android.dialer.DialerInternalPhoneNumber.CountryCodeSource country_code_source = 6;</code>
     */
    public Builder setCountryCodeSource(CountryCodeSource value) {
      copyOnWrite();
      instance.setCountryCodeSource(value);
      return this;
    }
    /**
     * <pre>
     * The source from which the country_code is derived.
     * </pre>
     *
     * <code>optional .com.android.dialer.DialerInternalPhoneNumber.CountryCodeSource country_code_source = 6;</code>
     */
    public Builder clearCountryCodeSource() {
      copyOnWrite();
      instance.clearCountryCodeSource();
      return this;
    }

    /**
     * <pre>
     * The carrier selection code that is preferred when calling this phone number
     * domestically. This also includes codes that need to be dialed in some
     * countries when calling from landlines to mobiles or vice versa. For
     * example, in Columbia, a "3" needs to be dialed before the phone number
     * itself when calling from a mobile phone to a domestic landline phone and
     * vice versa.
     * Note this is the "preferred" code, which means other codes may work as
     * well.
     * </pre>
     *
     * <code>optional string preferred_domestic_carrier_code = 7;</code>
     */
    public boolean hasPreferredDomesticCarrierCode() {
      return instance.hasPreferredDomesticCarrierCode();
    }
    /**
     * <pre>
     * The carrier selection code that is preferred when calling this phone number
     * domestically. This also includes codes that need to be dialed in some
     * countries when calling from landlines to mobiles or vice versa. For
     * example, in Columbia, a "3" needs to be dialed before the phone number
     * itself when calling from a mobile phone to a domestic landline phone and
     * vice versa.
     * Note this is the "preferred" code, which means other codes may work as
     * well.
     * </pre>
     *
     * <code>optional string preferred_domestic_carrier_code = 7;</code>
     */
    public String getPreferredDomesticCarrierCode() {
      return instance.getPreferredDomesticCarrierCode();
    }
    /**
     * <pre>
     * The carrier selection code that is preferred when calling this phone number
     * domestically. This also includes codes that need to be dialed in some
     * countries when calling from landlines to mobiles or vice versa. For
     * example, in Columbia, a "3" needs to be dialed before the phone number
     * itself when calling from a mobile phone to a domestic landline phone and
     * vice versa.
     * Note this is the "preferred" code, which means other codes may work as
     * well.
     * </pre>
     *
     * <code>optional string preferred_domestic_carrier_code = 7;</code>
     */
    public com.google.protobuf.ByteString
        getPreferredDomesticCarrierCodeBytes() {
      return instance.getPreferredDomesticCarrierCodeBytes();
    }
    /**
     * <pre>
     * The carrier selection code that is preferred when calling this phone number
     * domestically. This also includes codes that need to be dialed in some
     * countries when calling from landlines to mobiles or vice versa. For
     * example, in Columbia, a "3" needs to be dialed before the phone number
     * itself when calling from a mobile phone to a domestic landline phone and
     * vice versa.
     * Note this is the "preferred" code, which means other codes may work as
     * well.
     * </pre>
     *
     * <code>optional string preferred_domestic_carrier_code = 7;</code>
     */
    public Builder setPreferredDomesticCarrierCode(
        String value) {
      copyOnWrite();
      instance.setPreferredDomesticCarrierCode(value);
      return this;
    }
    /**
     * <pre>
     * The carrier selection code that is preferred when calling this phone number
     * domestically. This also includes codes that need to be dialed in some
     * countries when calling from landlines to mobiles or vice versa. For
     * example, in Columbia, a "3" needs to be dialed before the phone number
     * itself when calling from a mobile phone to a domestic landline phone and
     * vice versa.
     * Note this is the "preferred" code, which means other codes may work as
     * well.
     * </pre>
     *
     * <code>optional string preferred_domestic_carrier_code = 7;</code>
     */
    public Builder clearPreferredDomesticCarrierCode() {
      copyOnWrite();
      instance.clearPreferredDomesticCarrierCode();
      return this;
    }
    /**
     * <pre>
     * The carrier selection code that is preferred when calling this phone number
     * domestically. This also includes codes that need to be dialed in some
     * countries when calling from landlines to mobiles or vice versa. For
     * example, in Columbia, a "3" needs to be dialed before the phone number
     * itself when calling from a mobile phone to a domestic landline phone and
     * vice versa.
     * Note this is the "preferred" code, which means other codes may work as
     * well.
     * </pre>
     *
     * <code>optional string preferred_domestic_carrier_code = 7;</code>
     */
    public Builder setPreferredDomesticCarrierCodeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setPreferredDomesticCarrierCodeBytes(value);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:com.android.dialer.DialerInternalPhoneNumber)
  }
  private byte memoizedIsInitialized = -1;
  protected final Object dynamicMethod(
      MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new DialerInternalPhoneNumber();
      }
      case IS_INITIALIZED: {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return DEFAULT_INSTANCE;
        if (isInitialized == 0) return null;

        boolean shouldMemoize = ((Boolean) arg0).booleanValue();
        if (!hasCountryCode()) {
          if (shouldMemoize) {
            memoizedIsInitialized = 0;
          }
          return null;
        }
        if (!hasNationalNumber()) {
          if (shouldMemoize) {
            memoizedIsInitialized = 0;
          }
          return null;
        }
        if (shouldMemoize) memoizedIsInitialized = 1;
        return DEFAULT_INSTANCE;

      }
      case MAKE_IMMUTABLE: {
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        DialerInternalPhoneNumber other = (DialerInternalPhoneNumber) arg1;
        countryCode_ = visitor.visitInt(
            hasCountryCode(), countryCode_,
            other.hasCountryCode(), other.countryCode_);
        nationalNumber_ = visitor.visitLong(
            hasNationalNumber(), nationalNumber_,
            other.hasNationalNumber(), other.nationalNumber_);
        extension_ = visitor.visitString(
            hasExtension(), extension_,
            other.hasExtension(), other.extension_);
        italianLeadingZero_ = visitor.visitBoolean(
            hasItalianLeadingZero(), italianLeadingZero_,
            other.hasItalianLeadingZero(), other.italianLeadingZero_);
        numberOfLeadingZeros_ = visitor.visitInt(
            hasNumberOfLeadingZeros(), numberOfLeadingZeros_,
            other.hasNumberOfLeadingZeros(), other.numberOfLeadingZeros_);
        rawInput_ = visitor.visitString(
            hasRawInput(), rawInput_,
            other.hasRawInput(), other.rawInput_);
        countryCodeSource_ = visitor.visitInt(hasCountryCodeSource(), countryCodeSource_,
            other.hasCountryCodeSource(), other.countryCodeSource_);
        preferredDomesticCarrierCode_ = visitor.visitString(
            hasPreferredDomesticCarrierCode(), preferredDomesticCarrierCode_,
            other.hasPreferredDomesticCarrierCode(), other.preferredDomesticCarrierCode_);
        if (visitor == MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownField(tag, input)) {
                  done = true;
                }
                break;
              }
              case 8: {
                bitField0_ |= 0x00000001;
                countryCode_ = input.readInt32();
                break;
              }
              case 16: {
                bitField0_ |= 0x00000002;
                nationalNumber_ = input.readUInt64();
                break;
              }
              case 26: {
                String s = input.readString();
                bitField0_ |= 0x00000004;
                extension_ = s;
                break;
              }
              case 32: {
                bitField0_ |= 0x00000008;
                italianLeadingZero_ = input.readBool();
                break;
              }
              case 42: {
                String s = input.readString();
                bitField0_ |= 0x00000020;
                rawInput_ = s;
                break;
              }
              case 48: {
                int rawValue = input.readEnum();
                CountryCodeSource value = CountryCodeSource.forNumber(rawValue);
                if (value == null) {
                  super.mergeVarintField(6, rawValue);
                } else {
                  bitField0_ |= 0x00000040;
                  countryCodeSource_ = rawValue;
                }
                break;
              }
              case 58: {
                String s = input.readString();
                bitField0_ |= 0x00000080;
                preferredDomesticCarrierCode_ = s;
                break;
              }
              case 64: {
                bitField0_ |= 0x00000010;
                numberOfLeadingZeros_ = input.readInt32();
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (DialerInternalPhoneNumber.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:com.android.dialer.DialerInternalPhoneNumber)
  private static final DialerInternalPhoneNumber DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new DialerInternalPhoneNumber();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static DialerInternalPhoneNumber getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<DialerInternalPhoneNumber> PARSER;

  public static com.google.protobuf.Parser<DialerInternalPhoneNumber> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

